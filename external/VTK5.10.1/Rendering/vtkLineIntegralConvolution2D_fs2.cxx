/* DO NOT EDIT.
 * Generated by ../bin/vtkEncodeString
 * 
 * Define the vtkLineIntegralConvolution2D_fs2 string.
 *
 * Generated from file: /dscrhome/ab690/code/ETTK/dcc/external/VTK5.10.1/Rendering/vtkLineIntegralConvolution2D_fs2.glsl
 */
#include "vtkLineIntegralConvolution2D_fs2.h"
const char *vtkLineIntegralConvolution2D_fs2 =
"//=========================================================================\n"
"//\n"
"//  Program:   Visualization Toolkit\n"
"//  Module:    vtkLineIntegralConvolution2D_fs2.glsl\n"
"//\n"
"//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n"
"//  All rights reserved.\n"
"//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n"
"//\n"
"//     This software is distributed WITHOUT ANY WARRANTY; without even\n"
"//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n"
"//     PURPOSE.  See the above copyright notice for more information.\n"
"//\n"
"//=========================================================================\n"
"\n"
"// Filename: vtkLineIntegralConvolution2D_fs2.glsl\n"
"// Filename is useful when using gldb-gui\n"
"\n"
"#version 110\n"
"\n"
"#extension GL_ARB_draw_buffers : enable\n"
"\n"
"uniform sampler2D licTexture;\n"
"uniform float     uLicTexWid; // texture width\n"
"uniform float     uLicTexHgt; // texture height\n"
"\n"
"// shift to the neighboring fragment\n"
"float tcordxDelt = 1.0 / uLicTexWid;\n"
"float tcordyDelt = 1.0 / uLicTexHgt;\n"
"\n"
"// the 8 surrounding fragments accessed by the 3x3 Laplacian matrix\n"
"// -1 -1 -1\n"
"// -1  9 -1             \n"
"// -1 -1 -1\n"
"vec2  cordShift0 = vec2( -tcordxDelt,  tcordyDelt );\n"
"vec2  cordShift1 = vec2(  0.0,         tcordyDelt );\n"
"vec2  cordShift2 = vec2(  tcordxDelt,  tcordyDelt );\n"
"\n"
"vec2  cordShift3 = vec2( -tcordxDelt,  0.0        );\n"
"vec2  cordShift4 = vec2(  tcordxDelt,  0.0        );\n"
"\n"
"vec2  cordShift5 = vec2( -tcordxDelt, -tcordyDelt );\n"
"vec2  cordShift6 = vec2(  0.0,        -tcordyDelt );\n"
"vec2  cordShift7 = vec2(  tcordxDelt, -tcordyDelt );\n"
"\n"
"// used for handling exceptions\n"
"vec2  miniTCoord = vec2(       tcordxDelt,       tcordyDelt );\n"
"vec2  maxiTCoord = vec2( 1.0 - tcordxDelt, 1.0 - tcordyDelt );\n"
"vec4  miniTexVal = vec4( 0.0, 0.0, 0.0, 0.0 );\n"
"vec4  maxiTexVal = vec4( 1.0, 1.0, 1.0, 1.0 );\n"
"     \n"
"// perform a 3x3 Laplacian high-pass filter on the input image  \n"
"void main( void )\n"
"{\n"
"  int   bException;\n"
"  vec4  outputValu;\n"
"  vec4  fragTexVal = texture2D( licTexture, gl_TexCoord[0].st );\n"
"  \n"
"  // In pass #1 LIC (vtkLineIntegralConvolution2D_fs1), any fragment where \n"
"  // the vector is zero is assigned with a negative texture value (by negating\n"
"  // the associated input noise texture value). High-pass filtering is skipped\n"
"  // for this fragment in order to pass the original input noise value forward\n"
"  // to pass #2 LIC. The line below checks if the current is such a fragment.\n"
"  bvec4 exception0 = lessThan( fragTexVal, miniTexVal );\n"
"     \n"
"  // checks if this fragment has 8 valid surrounding fragments (in tcoords)\n"
"  bvec2 exception1 = lessThan   ( gl_TexCoord[0].st, miniTCoord );\n"
"  bvec2 exception2 = greaterThan( gl_TexCoord[0].st, maxiTCoord );\n"
"  \n"
"  // perform high-pass filtering\n"
"  outputValu  = fragTexVal * 9.0;\n"
"  outputValu -= texture2D( licTexture, gl_TexCoord[0].st + cordShift0 ) +\n"
"                texture2D( licTexture, gl_TexCoord[0].st + cordShift1 ) +\n"
"                texture2D( licTexture, gl_TexCoord[0].st + cordShift2 ) +\n"
"       \n"
"                texture2D( licTexture, gl_TexCoord[0].st + cordShift3 ) +\n"
"                texture2D( licTexture, gl_TexCoord[0].st + cordShift4 ) +\n"
"       \n"
"                texture2D( licTexture, gl_TexCoord[0].st + cordShift5 ) +\n"
"                texture2D( licTexture, gl_TexCoord[0].st + cordShift6 ) +\n"
"                texture2D( licTexture, gl_TexCoord[0].st + cordShift7 );\n"
"  \n"
"  // Checks if high-pass filtering produces out-of-range texture values\n"
"  // that might incur artifacts near the interface between the valid flow\n"
"  // areas and zero-vector areas. In case of such a filtering result, the\n"
"  // initial texture value (from the output of pass #1 LIC) is simply\n"
"  // adopted to suppress artifacts as much as possible.\n"
"  bvec4 exception3 = lessThan   ( outputValu, miniTexVal );\n"
"  bvec4 exception4 = greaterThan( outputValu, maxiTexVal );\n"
"  bException = int(  any( exception3 )  ) + int(  any( exception4 )  );\n"
"  outputValu = fragTexVal * float(     bException ) + \n"
"               outputValu * float( 1 - bException );\n"
"  \n"
"  // In cased of any invalid surrounding fragment, high-pass filtering is \n"
"  // skipped and the initial texture value (from the output of pass #1 LIC)\n"
"  // is employed instead.\n"
"  bException = int(  any( exception1 )  ) + int(  any( exception2 )  );\n"
"  bException = ( bException + 1 ) / 2;\n"
"  outputValu = fragTexVal * float(     bException ) + \n"
"               outputValu * float( 1 - bException );\n"
"  \n"
"  // In case of a zero-vector fragment, the negative texture value (the noise\n"
"  // texture value stored in the output of pass #1 LIC) is negated again below\n"
"  // to restore the positive noise texture value that is then forwarded to pass\n"
"  // #2 LIC as the input noise.             \n"
"  bException = int(  any( exception0 )  );\n"
"  outputValu = fragTexVal * float( 0 - bException ) + \n"
"               outputValu * float( 1 - bException );\n"
"  \n"
"  gl_FragData[0]= outputValu;\n"
"}\n"
"\n";

