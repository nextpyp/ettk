/* DO NOT EDIT.
 * Generated by ../bin/vtkEncodeString
 * 
 * Define the vtkLineIntegralConvolution2D_fs1 string.
 *
 * Generated from file: /dscrhome/ab690/code/ETTK/dcc/external/VTK5.10.1/Rendering/vtkLineIntegralConvolution2D_fs1.glsl
 */
#include "vtkLineIntegralConvolution2D_fs1.h"
const char *vtkLineIntegralConvolution2D_fs1 =
"//=========================================================================\n"
"//\n"
"//  Program:   Visualization Toolkit\n"
"//  Module:    vtkLineIntegralConvolution2D_fs1.glsl\n"
"//\n"
"//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n"
"//  All rights reserved.\n"
"//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n"
"//\n"
"//     This software is distributed WITHOUT ANY WARRANTY; without even\n"
"//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n"
"//     PURPOSE.  See the above copyright notice for more information.\n"
"//\n"
"//=========================================================================\n"
"\n"
"// Filename: vtkLineIntegralConvolution2D_fs1.glsl\n"
"// Filename is useful when using gldb-gui\n"
"\n"
"#version 110\n"
"\n"
"#extension GL_ARB_draw_buffers : enable\n"
"\n"
"// four input texture objects\n"
"uniform sampler2D texVectorField;    // TEXTURE0\n"
"uniform sampler2D texNoise;          // TEXTURE1\n"
"uniform sampler2D texLIC;            // TEXTURE2\n"
"uniform sampler2D texTCoords;        // TEXTURE3\n"
"\n"
"// step type\n"
"// 0: first access to the streamline center point\n"
"// 1: access to a regular / non-center streamline point\n"
"// 2: second access to the streamline center point\n"
"//    (due to a change in the streamline integration direction)\n"
"//\n"
"// Texture texTCoords is indexed for type #1 (i.e., bReset = 0) only\n"
"// while it is NOT indexed for type #0 and type #2 (i.e., bReset = 1)\n"
"// and instead the original texture coordinate (prior to any integration)\n"
"// is directly used.\n"
"//\n"
"// Type #0 and type #2 each contribute half the texture value since\n"
"// they access to the same streamline point.\n"
"// \n"
"// The accumulation texture texLIC is NOT accessed for type #0 because\n"
"// nothing has been accumulated upon the first integration step\n"
"uniform int   uStepType;\n"
"uniform int   uSurfaced;             // is surfaceLIC (0 / 1)?\n"
"uniform int   uLastPass;             // is the last pass of LIC (0 / 1)?\n"
"uniform int   uNumSteps;             // number of steps in each direction.\n"
"uniform int   uStepSign;             // +1: forward;    -1: backward.\n"
"uniform float uStepSize;             // step size in parametric space\n"
"             \n"
"// two modes for masking the texture value of a zero-vector fragment\n"
"// 0: retain the white noise texture value by storing the negated version\n"
"// 1: export ( -1.0, -1.0, -1.0, -1.0 ) for use by vtkSurfaceLICPainter\n"
"//    to make this LIC fragment totally transparent to show the underlying\n"
"//    geometry surface\n"
"uniform int   uMaskType;\n"
"\n"
"float   normalizer = 1.0 / float( 2 * uNumSteps + 1 ); // for normalization\n"
"\n"
"// functions defined in vtkLineIntegralConvolution2D_fs.glsl\n"
"vec2 rk2( vec2 xy, float h );\n"
"vec2 rk4( vec2 xy, float h );\n"
"vec2 getVector( vec2 tcords );\n"
"vec3 getNoiseColor( vec2 tcoord );\n"
" \n"
"\n"
"void main( void )\n"
"{ \n"
"  vec2 vector = getVector( gl_TexCoord[1].st );\n"
"  \n"
"  // ==== for surfaceLIC ====\n"
"  // Any fragment where the vector is zero needs to be assigned with a mask \n"
"  // texture value, either vec4( -1.0, -1.0, -1.0, -1.0 ) or the negated\n"
"  // version of the white noise texture value. The former is exploited by\n"
"  // vtkSurfaceLICPainter to make this LIC fragment totally transparent\n"
"  // to show the underlying geometry surface while the latter is used by the\n"
"  // high-pass filter (vtkLineIntegralConvolution2D_fs2, invoked between \n"
"  // two LIC passes that are employed for improved image quality) to ignore\n"
"  // such fragments. Otherwise the output of the high-pass filter (taking\n"
"  // pass #1's output as the input) would contain high-frequency noise while\n"
"  // the (pass #2) LIC process requires white noise from the zero-vector area.\n"
"  //\n"
"  // ==== for non-surfaceLIC ====\n"
"  // Any fragment where the vector is zero needs to be assigned with the \n"
"  // negated version of the white noise texture value ONLY UNLESS this is the\n"
"  // last pass of LIC, which is followed by a high-pass filter. Otherwise (it\n"
"  // is the last process of LIC) the fragment takes the white noise value for\n"
"  // the output.\n"
"  if (    all(   equal(  vector,  vec2( 0.0, 0.0 )  )   )    )\n"
"    {\n"
"    if ( uSurfaced == 1 ) \n"
"      {\n"
"      gl_FragData[0] = vec4(  ( -1.0 ) * getNoiseColor( gl_TexCoord[1].st ),  \n"
"                              ( -1.0 )  )             * float( 1 - uMaskType ) +\n"
"                       vec4( -1.0, -1.0, -1.0, -1.0 ) * float(     uMaskType );\n"
"      gl_FragData[1] = vec4( -1.0, -1.0, -1.0, -1.0 );\n"
"      } \n"
"    else\n"
"      {\n"
"      float   fscale = float( uLastPass + uLastPass - 1 );\n"
"      gl_FragData[0] = vec4(  fscale * getNoiseColor( gl_TexCoord[1].st ),  \n"
"                              fscale  );\n"
"      gl_FragData[1] = vec4(  fscale,  fscale,  fscale,  fscale  );\n"
"      }\n"
"      \n"
"    return;\n"
"    } \n"
"    \n"
"  // determine if the texture coordinate needs to be reset\n"
"  // bReset = 0: texture texTCoords needs to be indexed to obtain the coordinate\n"
"  //             for a regular / non-center streamline point.\n"
"  // bReset = 1: the original texture coordinate (prior to any integration) is\n"
"  //             used for the streamline center point.\n"
"  int  bReset = 1 - (  ( uStepType + 1 ) / 2  ) * ( 1 - uStepType / 2 );\n"
"   \n"
"  // obtain the actual texture coordinate\n"
"  vec2 tcord0;\n"
"  if(bReset==1)\n"
"    {\n"
"    tcord0=gl_TexCoord[1].st;\n"
"    }\n"
"  else\n"
"    {\n"
"    tcord0=texture2D( texTCoords, gl_TexCoord[0].st ).rg;\n"
"    }\n"
"\n"
"  // normalize the contribution of this streamline point to the center ask the \n"
"  // streamline center to contribute half the texture value per time (the stream-\n"
"  // line center is accessed two times)\n"
"  vec3 color0 = (  1.0  -  float( bReset )  *  0.5  ) * \n"
"                (  getNoiseColor( tcord0 )  *  normalizer  );\n"
"  \n"
"  // integration to locate the next streamline point              \n"
"  vec2 tcord1 = rk4(  tcord0,  float( uStepSign ) * uStepSize  );\n"
"  \n"
"  // access the accumulation texture to obtain the summed texture value that will \n"
"  // be eventually assigned to the streamline center (in fact, no accumulation is\n"
"  // accessed and used for type #0 --- the first access to the center)\n"
"  // NOTE: upon the first access to the center, the accumulation texture may (and\n"
"  // in many cases, at least on some platforms) contain invalid ('NAN') values.\n"
"  // Accessing the initial accumulation texture can cause problems.\n"
"  vec3 accumu = vec3( 0.0, 0.0, 0.0 );\n"
"  if ( uStepType > 0 )\n"
"    {\n"
"    accumu = texture2D( texLIC, gl_TexCoord[0].st ).rgb;\n"
"    }\n"
"    \n"
"  gl_FragData[0] = vec4( color0 + accumu, 1.0 );\n"
"  gl_FragData[1] = vec4( tcord1.s, tcord1.t, 0.0, 1.0 );\n"
"}\n"
"\n";

