/* DO NOT EDIT.
 * Generated by ../bin/vtkEncodeString
 * 
 * Define the vtkLineIntegralConvolution2D_fs string.
 *
 * Generated from file: /dscrhome/ab690/code/ETTK/dcc/external/VTK5.10.1/Rendering/vtkLineIntegralConvolution2D_fs.glsl
 */
#include "vtkLineIntegralConvolution2D_fs.h"
const char *vtkLineIntegralConvolution2D_fs =
"//=========================================================================\n"
"//\n"
"//  Program:   Visualization Toolkit\n"
"//  Module:    vtkLineIntegralConvolution2D_fs.glsl\n"
"//\n"
"//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n"
"//  All rights reserved.\n"
"//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n"
"//\n"
"//     This software is distributed WITHOUT ANY WARRANTY; without even\n"
"//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n"
"//     PURPOSE.  See the above copyright notice for more information.\n"
"//\n"
"//=========================================================================\n"
"\n"
"// Filename: vtkLineIntegralConvolution2D_fs.glsl\n"
"// Filename is useful when using gldb-gui\n"
"\n"
"// Provides a set of methods that the shaders can use.\n"
" \n"
"#version 110\n"
"\n"
"uniform sampler2D texVectorField; // TEXTURE0\n"
"uniform sampler2D texNoise;       // TEXTURE1\n"
"\n"
"uniform vec2 uNoise2VecScaling;   // scale = vector / noise\n"
"uniform vec2 uVectorTransform2;\n"
"uniform vec2 uVectorShiftScale;\n"
"uniform vec4 uVTCordRenderBBox;   // Bounding box of vector texture coordinates\n"
"uniform int  uNTCordShiftScale;   // to shift and scale noise texture coordinates\n"
"                                  // when the output of pass #1 LIC is high-pass \n"
"                                  // filtered and taken as the input 'noise' of \n"
"                                  // pass #2 LIC\n"
"vec2         noiseTexCordShift = vec2( -uVTCordRenderBBox.x, -uVTCordRenderBBox.z );\n"
"vec2         noiseTexCordScale = \n"
"                         vec2(  1.0 / ( uVTCordRenderBBox.y - uVTCordRenderBBox.x ),\n"
"                                1.0 / ( uVTCordRenderBBox.w - uVTCordRenderBBox.z )\n"
"                             );   // the texture coordinate scale factor\n"
"                             \n"
"vec2         miniVectorTCoords = vec2(  uVTCordRenderBBox.x,  uVTCordRenderBBox.z );\n"
"vec2         maxiVectorTCoords = vec2(  uVTCordRenderBBox.y,  uVTCordRenderBBox.w );\n"
"                             \n"
"// the range (of the vector field) that a single copy of the noise texture (note\n"
"// that the output of pass #1 LIC, after high-pass filtering, is just an extent / \n"
"// sub-range of the virtual full noise texture) covers --- the reciprocal of \n"
"// uNoise2VecScaling\n"
"vec2         NoiseTexOccupancy = vec2( 1.0, 1.0 ) / uNoise2VecScaling;\n"
"\n"
"// to save division\n"
"float        vcScaleReciprocal = 1.0 / uVectorShiftScale.y;\n"
"float        rungeKutta_1Sixth = 1.0 / 6.0;  // for rk4\n"
"\n"
"// Define prototype. \n"
"// This function is compiled in to select the two components that form\n"
"// the surface vector (see vtkLineIntegralConvolution2D.cxx for the\n"
"// actual code).\n"
"vec2 getSelectedComponents(vec4 color);\n"
"\n"
"// Given a vector field based coordinate tcords, this function returns\n"
"// the vector in \"Normalized Image\" space.\n"
"vec2 getVector( vec2 tcords )\n"
"{\n"
"  vec4 color  = texture2D( texVectorField, tcords );\n"
"  vec2 vector = getSelectedComponents( color );\n"
"  \n"
"  // since the forward tranformation is y = ( x + shift ) * scale,\n"
"  // now we perform backward transformation x = y / scale - shift\n"
"  // to obtain the original vector \n"
"  // note: vcScaleReciprocal = 1.0 / uVectorShiftScale.y\n"
"  vector = ( vector * vcScaleReciprocal ) - uVectorShiftScale.x;\n"
"  return vector * uVectorTransform2;\n"
"}\n"
"\n"
"// get the normalized vector at a given point\n"
"// note that direct use of the built-in function normalize( vec2 ) causes\n"
"// problems as it fails to handle zero-length vectors (division by zero)\n"
"vec2 getNormalizedVector( vec2 tcoord )\n"
"{ \n"
"  vec2   vector = getVector( tcoord );\n"
"  float  vecLen = length( vector );\n"
"  vec2   retVec = ( vecLen == 0.0 ) ? vec2( 0.0, 0.0 ) : ( vector / vecLen );\n"
"    \n"
"  // in case of an invalid vector texture coordinate\n"
"  bvec2  beLess = lessThan   ( tcoord, miniVectorTCoords );\n"
"  bvec2  greatr = greaterThan( tcoord, maxiVectorTCoords );\n"
"  int    error0 = int(  any( beLess )  );\n"
"  int    error1 = int(  any( greatr )  );\n"
"  int    errors = ( error0 + error1  + 1 ) / 2;\n"
"  \n"
"  return retVec * float( 1 - errors );\n"
"}\n"
"\n"
"// fourth-order Runge-Kutta streamline integration\n"
"vec2 rk2( vec2 point0, float fStep0 )\n"
"{\n"
"  vec2   vectr0 = getNormalizedVector(  point0                              );\n"
"  vec2   vectr1 = getNormalizedVector(  point0 + vectr0 * ( fStep0 * 0.5 )  );\n"
"  return point0 + vectr1 * fStep0; \n"
"}\n"
"\n"
"// fourth-order Runge-Kutta streamline integration\n"
"vec2 rk4( vec2 point0, float fStep0 )\n"
"{\n"
"  float  dtHalf = fStep0 * 0.5;\n"
"  vec2   vectr0 = getNormalizedVector( point0                   );\n"
"  vec2   vectr1 = getNormalizedVector( point0 + vectr0 * dtHalf );\n"
"  vec2   vectr2 = getNormalizedVector( point0 + vectr1 * dtHalf );\n"
"  vec2   vectr3 = getNormalizedVector( point0 + vectr2 * fStep0 );\n"
"  return (  point0 + ( vectr0 + vectr1 + vectr1 + vectr2 + vectr2 + vectr3 ) \n"
"                   * ( fStep0 * rungeKutta_1Sixth )  ); \n"
"}\n"
"\n"
"// given a vector field-based texture coordinate vectrTCord, this function\n"
"// accesses the noise texture (with a different size from that of the vector\n"
"// field for pass #1 LIC, or the same size for pass #2 LIC) to locate the \n"
"// target value\n"
"vec3 getNoiseColor( vec2 vectrTCord )\n"
"{\n"
"  // 'mod' tells the position (still vector field based) to which the current\n"
"  // fractional copy of the noise texture needs to be mapped (after possibly \n"
"  // several full copies) and this position is then transformed to the noise\n"
"  // texture space --- noiseTCord\n"
"  vec2 noiseTCord = mod( vectrTCord, NoiseTexOccupancy ) * uNoise2VecScaling;\n"
"  \n"
"  // When the output of pass #1 LIC is high-pass filtered and then taken\n"
"  // to pass #2 LIC as the input 'noise', the size of this 'noise' texture\n"
"  // (uVTCordRenderBBox) is equal to the current extent of the vector \n"
"  // field x this->Magnification (see vtkLineIntegralConvolution2D.cxx).\n"
"  // Since uNoise2VecScaling involves this->Magnification and hence the\n"
"  // value of uNoise2VecScaling for pass #2 LIC is just vec2(1.0, 1.0) AS\n"
"  // LONG AS we take this 'noise' texture as an extent (uVTCordRenderBBox) \n"
"  // of the virtual full 'noise' texture (for which the out-of-extent part\n"
"  // is just not defined / provided --- 'virtual'). To compensate for the \n"
"  // concept of this 'extent', the INITIAL (since uNoise2VecScaling is 1.0\n"
"  // by 1.0 above) vector field-based noise texture coordinate noiseTCord \n"
"  // needs to be shifted and scaled below to index this 'noise' texture (an \n"
"  // extent of the virtual full 'noise' texture) properly.\n"
"  vec2 tempTCoord = ( noiseTCord + noiseTexCordShift ) * noiseTexCordScale;\n"
"  noiseTCord = noiseTCord * float( 1 - uNTCordShiftScale ) + \n"
"               tempTCoord * float(     uNTCordShiftScale );\n"
"               \n"
"  // Given the 200 x 200 white noise (VTKData\\Data\\Data\\noise.png) currently\n"
"  // in use, half is actually used below (by multiplying the tcoord with 0.5)\n"
"  // for better image quality.\n"
"  noiseTCord = noiseTCord * (   float( uNTCordShiftScale + 1 ) * 0.5   );\n"
"  \n"
"  // now given a noise texture based coordinate, return the value\n"
"  return texture2D( texNoise, noiseTCord ).rgb;\n"
"}\n"
"\n";

